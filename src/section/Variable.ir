::^%.Code
  @context\context.Context\$
  @line\input.Line\$
  @scopeLevel\n\$
  @isPrivate\b\$
  rhs\s\$
  @codeLine\CodeLine|-\
  ^()
  code_input := &input.Line(@line.file, rhs, @line.rowIndex)
  @codeLine = &CodeLine(@context, code_input, &LineParser(code_input))

:re = ##
  \re.Element\
  => &re.Sequence(#).withCb(##)
      &re.SeqItem('(\:{0,2})', 'colons')
      &re.SeqItem('(\@?)', 'att')
      '\s*'
      &re.SeqItem('(\w+)', 'name')
      '\s*\=\s*'
      &re.SeqItem('(.*)', 'rest')
      --
      params\O\$
      scope\FileScope\$
      line\s\$
      header\input.Line\$
      => &%.Variable(#)
        scope.copyContextWithName(params.name)
        header
        params.colons.length
        !!params.att
        params.rest

:create = ##
  \%.Variable|-\
  scope\FileScope\$
  line\s\$
  header\input.Line\$
  re := /^(\:{0,2})(\@?)\s*(\w+)\s*\=\s*(.*)$/.exec(line)
  if !re
    => null

  scope_level := re[1].length
  is_private := !!re[2]
  name := re[3]
  rest := re[4]

  if scope_level == 2 && is_private
    error(header, 'global variable can not be private')
  => &%.Variable(#)
    scope.copyContextWithName(name)
    header
    scope_level
    is_private
    rest

:close^
  c := &CodeScope(@context, @)
  c.process(@.lines)

:transform^
  @.blocks.forEach(##)
    block\IndentBlock\$
    if block.hasValidLine
      @codeLine.addBlock(block)
  @codeLine.transform()

:output\A\
  if @scopeLevel == 0 && !@context.cls
    error(@line, 'class scope outside of class.')
  out := @codeLine.output()
  out.linePrefix = @context.scopedName(@scopeLevel).decl + ' = ' + out.linePrefix
  out.lineSuffix += ';'
  => [out.output, @.blocks.map(##)]
    block\IndentBlock\$
    => block.hasValidLine ? [] : block.output()
