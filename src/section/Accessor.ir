Overriding accessor.
::^%.Callable
  context\context.Context\$
  @name\s\$
  return_type\s\$
  @isGetter\b\$
  context.isMethod = true
  ^(context, return_type, [])

:create = ##
  \%.Accessor|-\
  scope\FileScope\$
  line\s\$
  header\input.Line\$
  re := /^\s*([a-zA-Z]\w*)\s*([+*])\s*(\\(.*)\\)?$/.exec(line)
  if !re
    => null

  // we should have seen a ctor.
  if !scope.context.cls
    error(header, 'accessor marker w/o class')
    => null
  name := re[1]
  access_type := re[2]
  ret_type := re[4]
  if ret_type
    ret_type = &type.Parser(scope.context, header, ret_type).parse()
  ctx := scope.copyContext(scope.context.cls.methodName(name))
  => &%.Accessor(ctx, name, ret_type, access_type == '+')

:output\A\
  member := @.context.cls.member(@name)
  // TODO: error if there is member and we have param or return type specified to the
  // accessor.
  // TODO: error if there is no member, but there are both getter and setter, and
  // their param and return type do not match. also error if the setter takes more
  // than one param (currently the check doesn't work if there's getter specified
  // before setter because getter adds a member and the 'member' var above is non-null
  // for the setter).
  if !member
    // accessor with no corresponding member. use the given param and return types.
    if @isGetter && !@.returnType
      error(@.lines[0], 'getter with no return type')
    if !@isGetter && @.params.numParams != 1
      error(@.lines[0], 'non-member setter should have one param')

    member_type := @isGetter ? # : #
      &type.Decoder(@.context.pkg, @.returnType)
      @.params.paramType(0)
    member = @.context.cls.addMember(#)
      @name
      member_type
      '&'
      true
  class_name := @.context.cls.name()
  => [#]
    member.outputDecl(class_name)
    member.outputAccessor(class_name, @isGetter, [#], @.params)
      whitespaces(@.block(0).indent) + 'var self = this;'
      @.outputBody('')
