:
  CODE_PARSER := null

::CodeLine <SectionHead
  @context\!Context\$
  @input+\InputLine\$
  @line_parsed\LineParser\$
  @parsed\parser.Result\
  @continue_lines&\!A.<!CodeLine>\ []
  @param&\Param|b\
  @matcher\BlockMatcher\
  %()

:+str\s\
  => @input.line

:+indent\n\
  => @line_parsed.indent

:+is_continuation\b\
  => @line_parsed.is_continuation

:+is_block_statement\b\
  => @matcher.is_block_statement

:+parsed\parser.Result\
  if (@.is_continuation)
    warn(@input, 'parse requested for cont. line')
  if (!@parsed)
    CODE_PARSER = CODE_PARSER || new parser.Target('ParseLine')
    @parsed = CODE_PARSER.run(#)
      [@input].concat(@continue_lines)
      new LineTransformer(@context, @input)
      true
  => @parsed

:transform
  code := (@param && @param !== true && @param.value_line) || @.parsed.code

  @matcher = new BlockMatcher(@context, @input, code, @.blocks)
  @matcher.transform()

:output\LineOutput\
  out := new LineOutput(@input)
  if (@param === true)
    => out

  out.append_lines(@.parsed.prev_lines.map(##))
    line\s\$
    => line + ';'
  out.append_lines(@matcher.first_line())
  @matcher.each_fragment(##)
    block\IndentBlock\$
    tail_code\A.<s>\$
    out.append_block(block.output())
    out.append_lines(tail_code)
  if (@param)
    @param.output_init(out)
  @.parsed.tail_comment.forEach(##)
    comment\s\$
    out.tail_comment.push(comment)
  out.append_lines(@parsed.next_lines)
  => out
