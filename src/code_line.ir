:
  CODE_PARSER := null

::CodeLine <section.Head
  @context\!context.Context\$
  @input+\input.Line\$
  @line_parsed\LineParser\$
  @parsed\parser.Result\
  @continue_lines&\!A.<!CodeLine>\ []
  @param&\Param|b\
  @matcher\BlockMatcher\
  %()

:+str\s\
  => @input.line

:+indent\n\
  => @line_parsed.indent

:+is_continuation\b\
  => @line_parsed.is_continuation

:+is_block_statement\b\
  => @matcher.is_block_statement

:+parsed\parser.Result\
  if @.is_continuation
    warn(@input, 'parse requested for cont. line')
  if !@parsed
    CODE_PARSER = CODE_PARSER || new parser.Target('ParseLine')
    lines := [@input].concat(@continue_lines)
    try
      @parsed = CODE_PARSER.run(#)
        lines
        new LineTransformer(@context, @input)
    catch e
      warn(@input, 'syntax error')
      e.context_lines.forEach(##)
        line\s\$
        console.warn(line)
      console.warn(e.message)
      process.exit(-1)
  => @parsed

:transform
  code := (@param && @param !== true && @param.value_line) || @.parsed.code

  @matcher = new BlockMatcher(@context, @input, code, @.blocks)
  @matcher.transform()

:output\output.Line\
  out := new output.Line(@input)
  if @param === true
    => out

  out.lines.append_lines(@.parsed.prev_lines.map(##))
    line\s\$
    => line + ';'
  @matcher.output(out)
  if @param
    @param.output_init(out)
  @.parsed.tail_comment.forEach(##)
    comment\s\$
    out.tail_comment.push(comment)
  => out
