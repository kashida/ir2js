:
  ARG_TYPE_REPLACE_MAP := {#}
    'boolean': 'Boolean'
    'function': 'Function'
    'string': 'String'
    'number': 'Number'
    // black list this one because closure compiler warns the refernce to this
    // constructor prevents some optimizations.
    'RegExp': 'null'

::ParamSet
  @context\!context.Context\$
  @block\IndentBlock\$
  @is_ctor\b\? false
  @params\A.<!Param>\ []
  @return_type\TypeDecoder\

:transform
  param_done := false
  @block.each_line(##, @context)
    line\SectionLine\$
    i\n\$
    if param_done
      =>
    if line instanceof SeparatorLine
      param_done = true
      =>
    if line instanceof CodeLine && !line.is_continuation
      p := @add_line(\CodeLine\(line), i)
      if p
        line.param = p
      else
        param_done = true
    // skip invalid lines and continuation lines.

:@add_line\Param|b\
  line\CodeLine\$
  index\n\$
  p := new Param(@context, @is_ctor, line.input, line.parsed)
  if !p.success
    if index != 0 || @context.is_file_scope
      => null
    // could be the return type.
    => @try_return_type(line.str)

  @params.push(p)
  if p.is_member
    @context.cls.add_member(p.name, p.type, p.access_type)
  => p

:@try_return_type\b\
  line\s\$
  re := /^\s*\\(.*)\\\s*$/.exec(line)
  if !re
    => false
  @return_type = new TypeDecoder(@context.pkg, re[1])
  => true

:set_return_type
  return_type\s\$
  if return_type
    @return_type = new TypeDecoder(@context.pkg, return_type)

:is_empty\b\
  => @params.length == 0

:is_init_empty\b\
  => !@params.some(##)
    p\Param\$
    => p.is_member || p.init_type == '?'

:is_decl_empty\b\
  => !@return_type && !@params.some(##)
    p\Param\$
    => !!p.type

:output_decls\!A.<s>\
  result := @params.map(##).filter(##)
    p\Param\$
    => p.output_decl()
    --
    s\s\$
    => !!s
  if @return_type
    result.push('@return {' + @return_type.output() + '}')
  => result

:output_params\s\
  // function parameter output.
  => @params.map(##).filter(##).join(', ')
    p\Param\$
    => p.output_param()
    --
    s\s\$
    => !!s

:output_argtypes\s\
  => '[' + @params.map(##).join(', ') + ']'
    p\Param\$
    => p.output_argtype()

:set_argtypes
  types\CallableType\$
  @params.forEach(##)
    p\!Param\$
    types.add_arg(p.argtype())
