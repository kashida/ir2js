Match markers and blocks.

::BlockMatcher
  @context\!context.Context\$
  @input\input.Line\$
  @code\A.<!parser.BlockMarker|s>\$
  @blocks\A.<!IndentBlock>\$
  @params\A.<!ParamSet>\ []
  @is_block_statement+\b\ false

:transform
  if @match_blocks()
    @transform_blocks()

Returns true only if matching succeeds.
:@match_blocks\b\
  itr := new CodeBlockItr(@input, @code, @blocks)
  itr.cb = ##
    type\s\$
    with_param\b\$
    if with_param
      sub_context := @context.clone()
      sub_context.is_file_scope = false
      param := new ParamSet(sub_context, @blocks[itr.bidx])
      @params.push(param)
  success := itr.run()
  @is_block_statement = itr.extra_block
  => success

:@transform_blocks
  itr := new CodeBlockItr(@input, @code, @blocks)
  itr.cb = ##
    type\s\$
    with_param\b\$
    // transform the blocks.
    if with_param
      @params[itr.pidx].transform()
    @blocks[itr.bidx].transform({#}[type])
      f: BlockType.BLOCK
      o: BlockType.OBJ
      a: BlockType.ARRAY
      p: BlockType.PARAMS
      l: BlockType.LINE
      '*': BlockType.MULT
      '+': BlockType.ADD
      '&&': BlockType.LOG_AND
      '||': BlockType.LOG_OR
  itr.run()

:output
  out\output.Line\$
  prev_block := null
  itr := new CodeBlockItr(@input, @code, @blocks)
  itr.cb = ##
    type\s\$
    with_param\b\$
    block := @blocks[itr.bidx]
    out.lines.append_lines(@compose_line(#))
      itr.cidx == 0 ? '' : \s\ (@code[itr.cidx - 1])
      prev_block
      block
      with_param ? @params[itr.pidx] : null
    out.lines.append_block(block.output())
    prev_block = block
  itr.run()
  if itr.ends_with_code
    out.lines.append_lines(@compose_line(#))
      \s\ (@code[itr.cidx])
      prev_block
      null
      null
  else if prev_block
    out.append_line(prev_block.end_str)

:@compose_line
  frg\s\$
  prev_block\IndentBlock\$
  next_block\IndentBlock\$
  next_param\ParamSet\$
  block_end := prev_block ? prev_block.end_str : ''
  block_start := next_block ? next_block.start_str : ''
  if !next_param
    => [block_end + frg + block_start]
  if next_param.is_decl_empty()
    => [#+]
      block_end + frg
      'function(' + next_param.output_params() + ')'
      block_start

  // we don't try to merge the frg into first line.
  => arr_flatten([#])
    block_end + frg
    doc_lines(next_param.output_decls())
    'function(' + next_param.output_params() + ')' + block_start
