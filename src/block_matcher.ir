Match markers and blocks.

::BlockMatcher
  @context\!context.Context\$
  @input\input.Line\$
  @code\A.<!parser.BlockMarker|s>\$
  @blocks\A.<!IndentBlock>\$
  @params\A.<!ParamSet>\ []
  @is_block_statement+\b\ false

:transform
  if @match_blocks()
    @transform_blocks()

Returns true only if matching succeeds.
:@match_blocks\b\
  itr := new CodeBlockItr(@input, @code, @blocks)
  itr.block_cb = ##
    type\s\$
    with_param\b\$
    if with_param
      sub_context := @context.clone()
      sub_context.is_file_scope = false
      param := new ParamSet(sub_context, @blocks[itr.bidx])
      @params.push(param)
  success := itr.run()
  @is_block_statement = itr.extra_block
  => success

:@transform_blocks
  itr := new CodeBlockItr(@input, @code, @blocks)
  itr.block_cb = ##
    type\s\$
    with_param\b\$
    // transform the blocks.
    if with_param
      @params[itr.pidx].transform()
    @blocks[itr.bidx].transform({#}[type])
      f: BlockType.BLOCK
      o: BlockType.OBJ
      a: BlockType.ARRAY
      p: BlockType.PARAMS
      l: BlockType.LINE
      '*': BlockType.MULT
      '+': BlockType.ADD
      '&&': BlockType.LOG_AND
      '||': BlockType.LOG_OR
  itr.run()

:output
  out\output.Line\$
  itr := new CodeBlockItr(@input, @code, @blocks)
  itr.block_cb = ##
    type\s\$
    with_param\b\$
    block := @blocks[itr.bidx]
    if with_param
      @output_params(out, @params[itr.pidx])
    out.lines.append_str(block.start_str)
    out.lines.append_block(block.output(type == 'l' ? itr.lidx : undefined))
    out.lines.append_str(block.end_str)
  itr.code_cb = ##
    out.lines.append_str(\s\ (@code[itr.cidx]))
  itr.run()

:@output_params
  out\output.Line\$
  param\ParamSet\$
  if param.is_decl_empty()
    out.lines.append_str('function(' + param.output_params() + ')')
  else
    // we don't try to merge the frg into first line.
    out.lines.terminate_line()
    out.lines.append_lines(doc_lines(param.output_decls()))
    out.lines.append_str('function(' + param.output_params() + ')')
